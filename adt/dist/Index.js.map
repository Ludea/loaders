{"version":3,"file":"Index.js","sourceRoot":"","sources":["../src/Index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ISceneLoaderPluginAsync,\n  ISceneLoaderPluginFactory,\n  ISceneLoaderAsyncResult,\n  ISceneLoaderPlugin,\n  ISceneLoaderPluginExtensions,\n  ISceneLoaderProgressEvent,\n} from \"@babylonjs/core/Loading/sceneLoader\";\nimport type { Scene } from \"@babylonjs/core/scene\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer\";\nimport { Buffer } from \"@babylonjs/core/Buffers\";\n//import { BoundingInfo } from \"@babylonjs/core/Culling\";\nimport { Vector3 } from \"@babylonjs/core/Maths\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { TransformNode } from \"@babylonjs/core/Meshes\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\n/*import {\n  CreateRGBAStorageTexture,\n  Texture,\n  RawTexture,\n} from \"@babylonjs/core/Materials/Textures\";*/\n//import { Engine } from \"@babylonjs/core/Engines\";\nimport {\n  //MapLayer,\n  MapChunk,\n  MapArea,\n  //MAP_LAYER_SPLAT_X,\n  //MAP_LAYER_SPLAT_Y,\n} from \"@wowserhq/format\";\nimport {\n  createTerrainVertexBuffer,\n  createTerrainIndexBuffer,\n  //mergeTerrainLayerSplats,\n} from \"./util\";\nimport { MapAreaSpec, TerrainSpec } from \"./types\";\n\nexport default class ADTFileLoader\n  implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory\n{\n  public wdtContent: any;\n  public name = \"adt\";\n  public extensions: ISceneLoaderPluginExtensions = {\n    \".adt\": { isBinary: true },\n  };\n  /** @internal */\n\n  public loadAssetContainerAsync(\n    scene: Scene,\n    data: string,\n    rootUrl: string,\n  ): Promise<AssetContainer> {\n    const container = new AssetContainer(scene);\n\n    return this.importMeshAsync(null, scene, data, rootUrl)\n      .then((result) => {\n        result.meshes.forEach((mesh) => container.meshes.push(mesh));\n        result.meshes.forEach((mesh) => {\n          const material = mesh.material;\n          if (material) {\n            // Materials\n            if (container.materials.indexOf(material) == -1) {\n              container.materials.push(material);\n\n              // Textures\n              const textures = material.getActiveTextures();\n              textures.forEach((t) => {\n                if (container.textures.indexOf(t) == -1) {\n                  container.textures.push(t);\n                }\n              });\n            }\n          }\n        });\n        return container;\n      })\n      .catch((ex) => {\n        throw ex;\n      });\n  }\n\n  public importMeshAsync(\n    meshesNames: any,\n    scene: Scene,\n    data: any,\n    rootUrl: string,\n    onProgress?: (event: ISceneLoaderProgressEvent) => void,\n    fileName?: string,\n  ): Promise<ISceneLoaderAsyncResult> {\n    //    const map =\n    //new Map().load(this.wdtContent);\n    const area = new MapArea(4).load(data);\n    let adt = new TransformNode(\"root\", scene);\n    let areaSpec = loadAreaSpec(area);\n    Promise.all(areaSpec.terrain.map((terrain) => createMesh(terrain, scene)))\n      .then((adtmeshes) => {\n        for (const mesh of adtmeshes) {\n          mesh.parent = adt;\n        }\n        //mesh.position = new Vector3(\n        //areaSpec.terrain.position[0],\n        //areaSpec.terrain[i].position[1],\n        //areaSpec.terrain[i].position[2],\n        // );\n      })\n      .catch((err) => console.log(err));\n\n    const array: Array<Promise<void>> = [];\n    const transformNodes: Array<TransformNode> = [];\n    transformNodes.push(adt);\n\n    return Promise.all(array).then(() => {\n      return {\n        meshes: [],\n        particleSystems: [],\n        skeletons: [],\n        animationGroups: [],\n        transformNodes: transformNodes,\n        geometries: [],\n        lights: [],\n        spriteManagers: [],\n      };\n    });\n  }\n\n  public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\n    //Get the 3D model\n    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {});\n  }\n\n  public loadWDT(wdt: any) {\n    this.wdtContent = wdt;\n  }\n\n  public createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\n    return new ADTFileLoader();\n  }\n}\n\nconst createTerrainGeometrySpec = (chunk: MapChunk) => {\n  const { vertexBuffer, bounds } = createTerrainVertexBuffer(\n    chunk.vertexHeights,\n    chunk.vertexNormals,\n  );\n  const indexBuffer = createTerrainIndexBuffer(chunk.holes);\n\n  return {\n    bounds,\n    vertexBuffer,\n    indexBuffer,\n  };\n};\n\n/*const createTerrainMaterialSpec = (chunk: MapChunk) => {\n  const splat = createTerrainSplatSpec(chunk.layers);\n  const layers = chunk.layers.map((layer) => ({\n    effectId: layer.effectId,\n    texturePath: layer.texture,\n  }));\n\n  return {\n    layers,\n    splat,\n  };\n};\n\nconst createTerrainSplatSpec = (layers: MapLayer[]) => {\n  // No splat (0 or 1 layer)\n\n  if (layers.length <= 1) {\n    return null;\n  }\n\n  // Single splat (2 layers)\n\n  if (layers.length === 2) {\n    return {\n      width: MAP_LAYER_SPLAT_X,\n      height: MAP_LAYER_SPLAT_Y,\n      data: layers[1].splat,\n      channels: 1,\n    };\n  }\n\n  // Multiple splats (3+ layers)\n\n  const layerSplats = layers.slice(1).map((layer) => layer.splat);\n  const mergedSplat = mergeTerrainLayerSplats(\n    layerSplats,\n    MAP_LAYER_SPLAT_X,\n    MAP_LAYER_SPLAT_Y,\n  );\n  return {\n    width: MAP_LAYER_SPLAT_X,\n    height: MAP_LAYER_SPLAT_Y,\n    data: mergedSplat,\n    channels: 4,\n  };\n};\n*/\n\nconst loadAreaSpec = (area: any) => {\n  const areaTableIds = new Uint32Array(area.chunks.length);\n  let terrainSpecs: TerrainSpec[] = [];\n\n  for (let i = 0; i < area.chunks.length; i++) {\n    const chunk = area.chunks[i];\n    areaTableIds[i] = chunk.areaId;\n\n    if (chunk.layers.length === 0) {\n      continue;\n    }\n\n    const terrainSpec = {\n      position: chunk.position,\n      geometry: createTerrainGeometrySpec(chunk),\n      //      material: createTerrainMaterialSpec(chunk),\n    };\n\n    terrainSpecs.push(terrainSpec);\n  }\n\n  const spec: MapAreaSpec = {\n    terrain: terrainSpecs,\n    areaTableIds,\n    doodadDefs: area.doodadDefs.map((def: any) => ({\n      id: def.id,\n      name: def.name,\n      position: def.position,\n      rotation: def.rotation,\n      scale: def.scale,\n    })),\n  };\n  return spec;\n};\n\nconst createMesh = async (spec: TerrainSpec, scene: any) => {\nconsole.log(spec);\n  let geometry = createGeometry(spec, scene);\n  //  const material = createMaterial(spec);\n  let childMesh = new Mesh(\"adt\", scene);\n  geometry.applyToMesh(childMesh);\n  childMesh.position = new Vector3(spec.position[0], spec.position[1], spec.position[2]);\n  return childMesh;\n};\n\nconst createGeometry = (spec: TerrainSpec, scene: any) => {\n  const vertexArray = new Float32Array(spec.geometry.vertexBuffer);\n  //const index = new Uint16Array(spec.geometry.indexBuffer);\n  const buffer = new Buffer(scene.getEngine(), vertexArray, false);\n\n  const positionsBuffer = new VertexBuffer(\n    scene.getEngine(),\n    buffer,\n    VertexBuffer.PositionKind,\n    false,\n    false,\n    4,\n    false,\n    0,\n    3,\n  );\n\n  const normalsBuffer = new VertexBuffer(\n    scene.getEngine(),\n    buffer,\n    VertexBuffer.NormalKind,\n    false,\n    undefined,\n    16,\n    undefined,\n    12,\n    4,\n    // 0,\n    //  true,\n  );\n\n  let geometry = new Geometry(\"geometry\", scene);\n  geometry.setVerticesBuffer(positionsBuffer);\n  geometry.setVerticesBuffer(normalsBuffer);\n  //geometry.setIndexBuffer(index, vertexArray.length / 4, index.length);\n\n  /* const minimum = new Vector3(\n    spec.bounds.minX,\n    spec.bounds.minY,\n    spec.bounds.minZ,\n  );\n  const maximum = new Vector3(\n    spec.geometry.bounds.maxX,\n    spec.bounds.maxY,\n    spec.bounds.maxZ,\n  ); */\n  //const center = new Vector3(spec.bounds.center[0], spec.bounds.center[1], s>\n  return geometry;\n};\n\n/* const createMaterial = async (spec: TerrainSpec) => {\n  const splatTexture = createSplatTexture(spec);\n  Promise.all(\n    spec.material.layers.map((layer) =>\n      fetch(\"http://localhost:8080\" + layer.texturePath).then((response) => {\n        const layerTextures = response;\n        //    const uniforms = { ...this.#mapLight.uniforms };\n\n        return new RawTexture(\n          layerTextures,\n          spec.material.layers.length,\n          splatTexture,\n          uniforms,\n        );\n      }),\n    ),\n  );\n};\n\nconst createSplatTexture = (spec: TerrainSpec) => {\n  const splat = spec.material.splat;\n\n  // No splat (0 or 1 layer)\n\n  if (!splat) {\n    // Return placeholder texture to keep uniforms consistent\n    return SPLAT_TEXTURE_PLACEHOLDER;\n  }\n\n  // Single splat (2 layers)\n\n  if (splat.channels === 1) {\n    const texture = new RawTexture(\n      splat.data,\n      splat.width,\n      splat.height,\n      Engine.TEXTUREFORMAT_R,\n    );\n    texture.minFilter = texture.magFilter = Texture.LINEAR_LINEAR;\n    texture.anisotropicFilteringLevel = 16;\n    texture.update();\n\n    return texture;\n  }\n\n  // Multiple splats (3+ layers)\n\n  const texture = CreateRGBAStorageTexture(\n    splat.data,\n    splat.width,\n    splat.height,\n  );\n  texture.minFilter = texture.magFilter = Texture.LINEAR_LINEAR;\n  texture.anisotropy = 16;\n  texture.needsUpdate = true;\n\n  return texture;\n};\n*/\n"]}