{"version":3,"file":"Index.js","sourceRoot":"","sources":["../src/Index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ISceneLoaderPluginAsync,\n  ISceneLoaderPluginFactory,\n  ISceneLoaderAsyncResult,\n  ISceneLoaderPlugin,\n  ISceneLoaderProgressEvent,\n} from \"@babylonjs/core/Loading/sceneLoader\";\nimport type { Scene } from \"@babylonjs/core/scene\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { MeshBuilder } from \"@babylonjs/core/Meshes/meshBuilder\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData\";\nimport { Map, MapArea } from \"@wowserhq/format\";\nimport { createTerrainVertexBuffer, createTerrainIndexBuffer } from \"util\";\n\nexport default class ADTFileLoader\n  implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory\n{\n  public wdtContent: any;\n  public name = \"adt\";\n  public extensions = \".adt\";\n\n  /** @internal */\n\n  public loadAssetContainerAsync(\n    scene: Scene,\n    data: string,\n    rootUrl: string,\n  ): Promise<AssetContainer> {\n    const container = new AssetContainer(scene);\n\n    return this.importMeshAsync(null, scene, data, rootUrl)\n      .then((result) => {\n        result.meshes.forEach((mesh) => container.meshes.push(mesh));\n        result.meshes.forEach((mesh) => {\n          const material = mesh.material;\n          if (material) {\n            // Materials\n            if (container.materials.indexOf(material) == -1) {\n              container.materials.push(material);\n\n              // Textures\n              const textures = material.getActiveTextures();\n              textures.forEach((t) => {\n                if (container.textures.indexOf(t) == -1) {\n                  container.textures.push(t);\n                }\n              });\n            }\n          }\n        });\n        return container;\n      })\n      .catch((ex) => {\n        throw ex;\n      });\n  }\n\n  public importMeshAsync(\n    meshesNames: any,\n    scene: Scene,\n    data: any,\n    rootUrl: string,\n    onProgress?: (event: ISceneLoaderProgressEvent) => void,\n    fileName?: string,\n  ): Promise<ISceneLoaderAsyncResult> {\n    const map = new Map().load(this.wdtContent);\n    const areaData = data;\n    const area = new MapArea(map.layerSplatDepth).load(areaData);\n    var vertexData = new VertexData();\n    var adt = new Mesh(\"adt\", scene);\n    //let vertexBuffer;\n    let indexBuffer;\n    let spec: any;\n    for (const chunk of area.chunks) {\n      if (chunk.layers.length === 0) {\n        continue;\n      }\n      spec = createTerrainVertexBuffer(\n        chunk.vertexHeights,\n        chunk.vertexNormals,\n      );\n      indexBuffer = createTerrainIndexBuffer(chunk.holes);\n    }\n    const position = new Float32Array(spec.indexBuffer!);\n    const normals = new Float32Array(spec.vertexBuffer!);\n    const indices = new Uint16Array(indexBuffer!);\n    vertexData.positions = position;\n    vertexData.indices = indices;\n    vertexData.normals = normals;\n    vertexData.applyToMesh(adt);\n    const option = {\n      height: spec.bounds[0],\n      width: spec.bounds[1],\n    };\n    const box = MeshBuilder.CreateBox(\"box\", option, scene);\n    const array: Array<Promise<void>> = [];\n    const meshes: Array<Mesh> = [];\n    meshes.push(adt);\n    meshes.push(box);\n    return Promise.all(array).then(() => {\n      return {\n        meshes: meshes,\n        particleSystems: [],\n        skeletons: [],\n        animationGroups: [],\n        transformNodes: [],\n        geometries: [],\n        lights: [],\n      };\n    });\n  }\n\n  public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\n    //Get the 3D model\n    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {});\n  }\n\n  public loadWDT(wdt: any) {\n    this.wdtContent = wdt;\n  }\n\n  public createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\n    return new ADTFileLoader();\n  }\n}\n"]}